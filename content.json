{"meta":{"title":"blog","subtitle":"Screw1024","description":"","author":"陈永建","url":"https://Screw1024.github.io"},"pages":[{"title":"标签云","date":"2019-03-04T07:37:12.000Z","updated":"2019-03-08T01:06:03.383Z","comments":true,"path":"tags/index.html","permalink":"https://Screw1024.github.io/tags/index.html","excerpt":"","text":""},{"title":"为何建站 && 为何写作","date":"2019-03-05T03:23:07.000Z","updated":"2019-03-08T02:03:32.060Z","comments":true,"path":"about/index.html","permalink":"https://Screw1024.github.io/about/index.html","excerpt":"","text":"为何建站因为本人是地理信息科学专业的大三学生（2019年），作为交叉学科，我们在本科阶段要学的主要分为计算机编程知识、测绘遥感方面的专业知识、考研统考学科 基础学科知识。 搭建这个网站现阶段主要是为了记录在学习的过程中的技术收获，养成知识的归纳的习惯，另外就是写一些时事的看法 吐槽。😂 而最主要的目的，就是能够通过本站展示自己，如果能以此能找到三俩好友，幸甚至哉。😀 为何记录 人类区别于其他物种最重要的原因是，人类懂得记录，记录会推动人类反思，反思进而推动人类进步，而其他物种的生生不息大多只体现在繁衍上。 带着自己的思考记录，在自己回首再读的时候，或许能够发现当时的思维的局限，能够明白自己是否在进步。过年期间没事时，又看了一遍黎明之前跟大秦帝国，觉得自己能够对人物之间的解读突然上了一个层次，而这是突然发现的，所以想通过平时记录一些时事，一做学习之余的消遣，二为以后反思提供资料。 补充简言之，本站是一个记录技术和思考的原创个人博客。 现阶段主要是计算机方面的一些总结，可以获得成就奖嘛😜。以后打算走GIS开发路线，如果能够顺利，希望以后能够有机会写一些GIS方面的总结，因为本人能力有限，在学校阶段主要精力放在了计算机上了。 文章中如若发现错误或不当言论，还望您不吝赐教。 关于作者在校生，刚把前端基础学的差不多（顺带说下，通过搭建本站终于懂了node的模块化的好处了）。目前正在学Python，想学习一下Django以及爬虫，这些都是以后web gis的技术要求。 技术交流、开车交友请右转找微信小图标🙃","keywords":"陈永建，陈永建的博客，永远的“白带”选手"}],"posts":[{"title":"http1,http2和https的前世今生","slug":"http和https","date":"2019-03-22T13:56:45.000Z","updated":"2019-03-23T00:43:00.797Z","comments":true,"path":"backend/understand http and https-1553263026.html","link":"","permalink":"https://Screw1024.github.io/backend/understand http and https-1553263026.html","excerpt":"","text":"一、前言： 先来观察这两张图，第一张访问域名http://www.12306.cn, 谷歌浏览器提示不安全链接，第二张是https://kyfw.12306.cn/otn/regist/init, 浏览器显示安全，为什么会这样子呢？2017年1月发布的Chrome 56浏览器开始把收集密码或信用卡数据的HTTP页面标记为“不安全”，若用户使用2017年10月推出的Chrome 62，带有输入数据的HTTP页面和所有以无痕模式浏览的HTTP页面都会被标记为“不安全”，此外，苹果公司强制所有iOS App在2017年1月1日前使用HTTPS加密。 二、HTTP和HTTPS发展历史什么是HTTP? 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 发展历史： 版本 产生时间 内容 发展现状 HTTP/0.9 1991年 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 没有作为正式的标准 HTTP/1.0 1996年 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令 正式作为标准 HTTP/1.1 1997年 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码 2015年前使用最广泛 HTTP/2 2015年 多路复用、服务器推送、头信息压缩、二进制协议等 逐渐覆盖市场 这个Akamai公司建立的一个官方的演示，使用HTTP/1.1和HTTP/2同时请求379张图片，观察请求的时间，明显看出HTTP/2性能占优势。 多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。 什么是HTTPS？ 《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。 参考连接：1.https://kamranahmed.info/blog/2016/08/13/http-in-depth/2.https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol3.https://tools.ietf.org/html/rfc19454.https://http2.github.io/http2-spec/5.https://www.zhihu.com/question/34074946 三、HTTP VS HTTPSHTTP特点： 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。 基于请求和响应：基本的特性，由客户端发起请求，服务端响应 简单快速、灵活 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性 下面通过一个简单的抓包实验观察使用HTTP请求传输的数据： 结果分析：HTTP协议传输数据以明文形式显示针对无状态的一些解决策略：场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。 通过Cookie/Session技术 HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接 HTTPS特点：​ 基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护 通过抓包可以看到数据不是明文传输，而且HTTPS有如下特点： 内容加密：采用混合加密技术，中间者无法直接查看明文内容 验证身份：通过证书认证客户端访问的是自己的服务器 保护数据完整性：防止传输的内容被中间人冒充或者篡改 混合加密：结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。 数字摘要：通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。 数字签名技术：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。 收方能够证实发送方的真实身份； 发送方事后不能否认所发送过的报文； 收方或非法者不能伪造、篡改报文。 非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。 四、HTTP通信传输 客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的运用层协议，所以通信的过程其实是对应数据的入栈和出栈。 报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。 为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。 为什么需要四次挥手呢？TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。 五、HTTPS实现原理 client向server发送请求https://baidu.com, 然后连接到server的443端口。 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。 客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（秘钥）。然后用证书对该随机值进行加密。 传送加密信息这部分传送的是用证书加密后的秘钥，目的就是让服务端得到这个秘钥，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段加密信息服务端用私钥解密秘密秘钥，得到了客户端传过来的私钥，然后把内容通过该值进行对称加密。 传输加密后的信息这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。 问题：1.怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？ 2.证书如何安全传输，被掉包了怎么办？ 数字证书包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要，然后根据证书上描述的计算证书的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。 那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名 六、运用与总结安全性考虑： HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用 SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。 成本考虑： SSL证书需要购买申请，功能越强大的证书费用越高 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。 HTTPS连接缓存不如HTTP高效，流量成本高。 HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。 HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。 原文：https://blog.csdn.net/xiaoming100001/article/details/81109617","categories":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}],"tags":[{"name":"tcp/ip协议","slug":"tcp-ip协议","permalink":"https://Screw1024.github.io/tags/tcp-ip协议/"}],"keywords":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}]},{"title":"那么微弱的“白日焰火”","slug":"白日焰火","date":"2019-03-16T06:25:23.000Z","updated":"2019-04-02T11:01:57.420Z","comments":true,"path":"reading/Black Coal,Thin Ice-1552717523.html","link":"","permalink":"https://Screw1024.github.io/reading/Black Coal,Thin Ice-1552717523.html","excerpt":"","text":"昨晚动用了一个月一次熬夜看电影的机会，还好《白日焰火》没让我失望😁，好电影而不出名可惜了。 一部优秀的电影，总是能引人深思，给不同的人能够有不同的理解。同时，优秀的电影，镜头语言会让人回味无穷，如张自力踢的那个空啤酒瓶，顺坡一直向下滑动，一是能表明工厂的管理不严，才能为梁志军抛尸提供条件，二是暗示张自立的命运走向下坡，因为后来成了保安。 镜头语言很多，留着以后慢慢品味，而整个剧情的理解亦有很多，而更考研逻辑和人情我的推测大致如下🙃： 1、居委会的第一段戏，大妈一上来就说最近来了几个南方人，不像干传销的，说明当时的环境对待南方人是有地域歧视的，第二段戏中有一匹马没有地方去，被接到居委会，而大妈在此景下跟王队长说洗衣店老板跟女主的关系，暗指是干洗店老板收留了来自南方的女主，同时也符合更加女主的形象气质（不像黑龙江人）。 2、妓女每次在车上换衣服，而没发生关系，揭示了老板的性无能，女主在其店里被猥亵，梁志军可能知道，但是念及收留女主之恩，并且没有触及梁志军底线，而放了他。 3、在宾馆的戏中，梁志军几次想搂着女主而又放下，并对女主说“我被发现了”，女主此时的表情是冷漠的。由此，我推测，梁一开始就是单方面“喜欢”女主，并一直在监视女主的活动，时不时联系，不让女主跟别的男人有接触，并且程度是逐步加深的，第一个开始是快要结婚时候，将其杀害，第二个就是刚恋爱。可能，男主自认为爱着女主吧，这也是他被出卖时，路过女主旁边而没用采取复仇行为的原因。 4、洗衣店老板，在最后的镜头中，给女主送围巾，我猜他是真不知道女主的杀人案，想要猥亵女主是一方面，另一方面也是真正的觉得女主可怜，否则不会留其继续上班，没有因为女主跟三桩命案有关，而赶她走。同时也回应张力军打趣说开夫妻店，他说的“我看得上人家，人家看不上我”，暗指自己没用性能力。 5、剧情的起点来了，随着找到白日焰火的老板娘推测到，当初迷惑警察的尸体就是那个皮氅的主人。时间来到1999年，女主孤生一人来到黑龙江，被洗衣店老板收留，在此时认识了梁，而梁沉默寡言，两人也算同病相怜，梁喜欢吴，而吴只是将其当作朋友（备胎）。再其后，女主因为刚来洗衣店，不熟练，洗坏了一件皮氅。她无力偿还，而对方又刚好是男人，只能把自己给对方来换回平静生活，将其带到某处地方发生关系后，皮氅的主人想要再来一次，而此时的女主不愿意，并做出了强烈反抗，一直“担心”而监视她的梁实在忍受不了，将其杀害。女主配合梁完成了分尸谎言，从而成为了“杀人犯”，并一直活在梁的阴影中。 6、张自力到来给已经麻木的女主身边，给她带来了一丝希望。在经历警告过张自力，不要跟着她之后，张说出滑冰鞋，这一重要信息，女主推测出张自力便衣“警察”的身份，她想利用这个警察能够抓住梁，从而获得解放，她知道梁因为喜欢女主，而不会将其供出。在梁被击毙之后，女主第二天进店时就涂了口红，她觉得她可以过有色彩的生活了。而后来，洗衣店老板有意还是无意的提醒下，张找到了白日焰火的老板娘，他知道女主肯定也参与了犯罪，张自力想要女主说出当年的实情，他就可以凭借又一新功恢复警察并可能晋升。这时的女主，原本想要跟着张自力过平凡的生活，在张自力叫其自首时，顿时绝望，索性成全了张自力的野心，这可以在最后女主指认现场时对环境的生疏以及在警车上那两行死寂的泪水可以看出。 总结：之所以叫《白日焰火》，我想第一层原因是显而易见的，白日焰火夜总会的老板的皮氅被女主洗坏了，是整个电影剧情发展的起点，这是显而易见的。第二层原因是，张自力为了功劳让女主自首，而女主成全他的野心，他内心极度扭曲，在白天给女主放烟花，一来表示谢意，二来庆祝自己，最后到舞厅，陷入了癫狂。 以上是我基础国内版（看完才知道，还有国内删除不少镜头😭），得出的我能理解的合理的解释，但是感觉洗衣店老板的角色没有这么简单，因为给张自力皮氅的时候，就直接从台下拿出来，并且里面已经准备好了线索，看着像是有意给张自力提供的，但是我却无法将这个举动拿到整个剧情中，对我来说好难过，也希望以后随着阅历的增长，以及看看未删减的剧情，我能给出跟好的解释😀，电影的乐趣，也莫过于此。 最近，韩国的李胜利事件这两天扯出一系列腐败，我国舆论普遍对韩国记者的职业操守表示钦佩，政权干预媒体，让有职业操守的媒体人都下岗了，直到朴槿惠快要下台时才有转机。 真相是什么？真相一定要符合大部分人的利益，或者说是符合有绝对权力人的利益。就像白日焰火里1999年死的夜总店老板被梁志军分尸后，仅凭当时的小王看到了身份证就证明死者是梁志军，这不是很草率嘛。当时的碎尸案弄的整个黑龙江人心惶惶，急需快速解决，维护社会安定，这符合当时当局者的利益，所以就认定尸体是梁志军的。 老板娘后来说，第二年去报警说丈夫不见了，如果碎尸案没有定案，是否会被某一角落里的刑警联系起来呢，从而抓住梁志军，也不会发生后面两起分尸案了。 说回韩国，不正是后面的总统想要上台，才会允许韩国媒体报道朴槿惠的闺蜜们事件，世越号事件嘛，当时的政治力量，可能已经是朴槿惠方处在下风吧，报道朴槿惠和其前任的丑闻，符合现任总统的利益。（我平时不说这些哒，感觉像中年油腻男😂）","categories":[{"name":"读书","slug":"reading","permalink":"https://Screw1024.github.io/categories/reading/"}],"tags":[{"name":"-movie","slug":"movie","permalink":"https://Screw1024.github.io/tags/movie/"}],"keywords":[{"name":"读书","slug":"reading","permalink":"https://Screw1024.github.io/categories/reading/"}]},{"title":"python多线程拷贝文件夹","slug":"python多进程拷贝文件夹","date":"2019-03-13T02:42:40.171Z","updated":"2019-03-16T12:59:02.463Z","comments":true,"path":"backend/copy dir by Multiple processes-1552445582.html","link":"","permalink":"https://Screw1024.github.io/backend/copy dir by Multiple processes-1552445582.html","excerpt":"","text":"进程vs程序程序：编写的具有一定功能的代码 进程：运行的代码（区别是环境+是否正在运行） python中进程的三个知识1.os模块的fork()方法 2.multiprocessing模块 3.数据共享multiprocessing模块的Manager 进度显示1234567891011#执行时判断进程，%在输出需要用两个，因为转义字符 num = 0 allFilenum = len(fileNames) while num&lt;allFilenum: queue.get() num += 1 copyRate = num/allFilenum print(\"\\r进度:%.2f%%\"%(copyRate*100),end=\"\") # end=\"表示不换行\" print(\"已完成\") 核心就是先获取总任务的文件数，再用完成的文件/总任务 特别注意的是，他是一直在打印进度，不过不换行，另再输出“%”时，需要注意转义字符。 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from multiprocessing import Pool,Managerimport osdef copyFile(name,oldFolderName,newFolderName,queue): fr = open(oldFolderName+\"/\"+name) fw = open(newFolderName+\"/\"+name,\"w\") content = fr.read() fw.write(content) fr.close() fw.close() queue.put(name)# 类似其他语言的入口函数，增强可读性 def main(): #用户输入当前目录下需要拷贝的文件夹名 oldFolderName = input(\"请输入需要拷贝的文件夹的名字：\") #创建新文件夹 newFolderName = oldFolderName + \"副本\" os.mkdir(newFolderName) #获取old文件夹中所有的文件名字 fileNames = os.listdir(oldFolderName) #多线程拷贝文件 pool = Pool(5) queue = Manager().Queue() for name in fileNames: pool.apply_async(copyFile,args=(name,oldFolderName,newFolderName,queue)) #执行时判断进程，%在输出需要用两个，因为转义字符 num = 0 allFilenum = len(fileNames) while num&lt;allFilenum: queue.get() num += 1 copyRate = num/allFilenum print(\"\\r进度:%.2f%%\"%(copyRate*100),end=\"\") # end=\"表示不换行\" print(\"已完成\") # pool.close() # pool.join()#通过__name__这个内置变量，在程序运行是他的值是__main__#这样就只能在调用时执行其中代码，代替其他语言的入口函数#同时__name__在被其他模块引入时，值为当前的包的结构if __name__ == \"__main__\": main()","categories":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}],"tags":[{"name":"-Python","slug":"Python","permalink":"https://Screw1024.github.io/tags/Python/"}],"keywords":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}]},{"title":"如何理解Python中的\"入口函数\"","slug":"Python中的入口函数","date":"2019-03-13T00:58:22.000Z","updated":"2019-03-16T13:14:28.587Z","comments":true,"path":"backend/understand main()  in Python-1552438702.html","link":"","permalink":"https://Screw1024.github.io/backend/understand main()  in Python-1552438702.html","excerpt":"","text":"1. 摘要通俗的理解__name__ == &#39;__main__&#39;：假如你叫小明.py，在朋友眼中，你是小明(__name__ == &#39;小明&#39;)；在你自己眼中，你是你自己(__name__ == &#39;__main__&#39;)。 if __name__ == &#39;__main__&#39;的意思是：当.py文件被直接运行时，if __name__ == &#39;__main__&#39;之下的代码块将被运行；当.py文件以模块形式被导入时，if __name__ == &#39;__main__&#39;之下的代码块不被运行。 2. 程序入口对于很多编程语言来说，程序都必须要有一个入口，比如C，C++，以及完全面向对象的编程语言Java，C#等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C，C++都需要有一个main函数作为程序的入口，也就是程序的运行会从main函数开始。同样，Java，C#必须要有一个包含Main方法的主类，作为程序入口。 而Python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。 一个Python源码文件（.py）除了可以被直接运行外，还可以作为模块（也就是库），被其他.py文件导入。不管是直接运行还是被导入，.py文件的最顶层代码都会被运行（Python用缩进来区分代码层次），而当一个.py文件作为模块被导入时，我们可能不希望一部分代码被运行。 2.1 一个.py文件被其他.py文件引用假设我们有一个const.py文件，内容如下： 12345678PI = 3.14def main(): print(\"PI:\", PI)main()# 运行结果：PI: 3.1412345678 现在，我们写一个用于计算圆面积的area.py文件，area.py文件需要用到const.py文件中的PI变量。从const.py中，我们把PI变量导入area.py： 123456789101112131415from const import PIdef calc_round_area(radius): return PI * (radius ** 2)def main(): print(\"round area: \", calc_round_area(2))main()'''运行结果：PI: 3.14round area: 12.56'''123456789101112131415 2.2 修改const.py，添加if __name__ == &quot;__main__&quot;我们看到const.py中的main函数也被运行了，实际上我们不希望它被运行，因为const.py提供的main函数只是为了测试常量定义。这时if __name__ == &#39;__main__&#39;派上了用场，我们把const.py改一下，添加if __name__ == &quot;__main__&quot;： 1234567PI = 3.14def main(): print(\"PI:\", PI)if __name__ == \"__main__\": main()1234567 运行const.py，输出如下： 1PI: 3.141 运行area.py，输出如下： 1round area: 12.561 如上，我们可以看到if __name__ == &#39;__main__&#39;相当于Python模拟的程序入口，Python本身并没有这么规定，这只是一种编码习惯。由于模块之间相互引用，不同模块可能有这样的定义，而程序入口只有一个。到底哪个程序入口被选中，这取决于__name__的值。 3. __name__3.1 __name__反映一个包的结构__name__是内置变量，可用于反映一个包的结构。假设我们有一个包a，包的结构如下： 12345a├── b│ ├── c.py│ └── __init__.py└── __init__.py12345 在包a中，文件c.py，__init__.py，__init__.py的内容都为： 1print(__name__)1 当一个.py文件（模块）被其他.py文件（模块）导入时，我们在命令行执行 1python -c \"import a.b.c\"1 输出结果： 123aa.ba.b.c123 由此可见，__name__可以清晰地反映一个模块在包中的层次。 3.2 __name__表示当前模块的名字__name__是内置变量，可用于表示当前模块的名字。我们直接运行一个.py文件（模块） 1python a/b/c.py1 输出结果： 1__main__1 由此我们可知：如果一个.py文件（模块）被直接运行时，则其没有包结构，其__name__值为__main__，即模块名为__main__。 所以，if __name__ == &#39;__main__&#39;的意思是：当.py文件被直接运行时，if __name__ == &#39;__main__&#39;之下的代码块将被运行；当.py文件以模块形式被导入时，if __name__ == &#39;__main__&#39;之下的代码块不被运行。 4. __main__.py文件与python -mPython的-m参数用于将一个模块或者包作为一个脚本运行，而__main__.py文件相当于是一个包的“入口程序“。 4.1 运行Python程序的两种方式 python xxx.py，直接运行xxx.py文件 python -m xxx.py，把xxx.py当做模块运行 假设我们有一个文件run.py，内容如下： 123import sysprint(sys.path)123 我们用直接运行的方式启动 1python run.py1 输出结果(为了说明问题，输出结果只截取了重要部分，下同)： 1['/home/huoty/aboutme/pythonstudy/main', ...]1 然后以模块的方式运行: 1python -m run.py1 输出内容 12['', ...]/usr/bin/python: No module named run.py12 由于输出结果只列出了关键的部分，应该很容易看出他们之间的差异： 直接运行方式是把run.py文件所在的目录放到了sys.path属性中 以模块方式运行是把你输入命令的目录（也就是当前工作路径），放到了 sys.path 属性中。 以模块方式运行还有一个不同的地方：多出了一行No module named run.py的错误。实际上以模块方式运行时，Python先对run.py执行一遍 import，所以print(sys.path)被成功执行，然后Python才尝试运行run.py模块，但是在path变量中并没有run.py这个模块，所以报错。正确的运行方式，应该是python -m run。 4.2 __main__.py的作用仍然先看例子，假设我们有如下一个包package： 123package├── __init__.py└── __main__.py123 其中，文件__init__.py的内容 1234import sysprint(\"__init__\")print(sys.path)1234 其中，文件__main__.py的内容 1234import sysprint(\"__main__\")print(sys.path)1234 接下来，我们运行这个package，使用python -m package运行，输出结果： 12345__init__['', ...]__main__['', ...]12345 使用python package运行，输出结果： 12__main__['package', ...]12 总结一下 当加上-m参数时，Python会把当前工作目录添加到sys.path中；而不加-m时，Python则会把脚本所在目录添加到sys.path中。 当加上-m参数时，Python会先将模块或者包导入，然后再执行。 __main__.py文件是一个包或者目录的入口程序。不管是用python package还是用python -m package运行，__main__.py文件总是被执行。 5. 原文链接如何简单地理解Python中的if name == ‘main‘","categories":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}],"tags":[{"name":"-Python","slug":"Python","permalink":"https://Screw1024.github.io/tags/Python/"}],"keywords":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}]},{"title":"GIS大牛开发个人博客归纳","slug":"GIS大牛开发博客归纳","date":"2019-03-08T02:28:09.000Z","updated":"2019-03-09T00:59:28.142Z","comments":true,"path":"GIS/GIS development blog-1552012144.html","link":"","permalink":"https://Screw1024.github.io/GIS/GIS development blog-1552012144.html","excerpt":"","text":"​ Esri中国信息技术有限公司是Esri公司在中国大陆的唯一分支机构，为客户提供基于地理信息技术的系统设计咨询、技术支持、教育培训等服务，还与“中国科学院国家资源与环境信息重点试验室”联合建立了“ArcGIS中国培训中心”，并与国内200多家单位和专业机构建立了合作伙伴业务关系，为用户提供全方位的解决方案。 ​ 总是通过Google找各种GIS相关的blog，这次，把国内外所有的GIS相关的高价值的blog全部打包，一个不剩，统统贡献出来。 ​ 注意：国外的博客需要科学上网才能打开😜。 Blog 描述 1 Esri Blog Esri官方博客，最权威的ArcGIS信息来源。 2 Baocai Zhang Esri北京研发中心大牛的博客。 3 Zhifang Wang Esri北京研发中心大牛的博客。 4 Qun Sun Esri北京研发中心大牛的博客。 5 Guodong Song Esri北京研发中心大牛的博客。 6 Very Spatial WVU毕业的学生创建，GIS信息园地。 7 All Points Blog 超好的GIS博客，内容全面，从理论到实践，紧跟GIS技术前沿。 8 James Fee GIS Blog James Fee的个人博客，超丰富的内容。 9 Po Ve Sham 非常实用的有关地理空间技术和环境学的博客，还有大量关于Open Street Map的文章。 10 Bostonography 专注于美国波士顿地理信息的博客，N多数据分析文章和漂亮的可视化特效。 11 The Offical Blog of Fortius One – Now GeoIQ Blog FortiusOne是一家地理信息技术公司（现已被Esri收购），有很多可视化特效和在线数据分析，以及数据共享方面的产品，不过他们的很多博客都是在讲他们的产品。 12 Mapperz, The Mapping News Blog N多关于Google Maps和Mash-ups的文章。 13 SlashGeo 超多关于GIS行业的新闻文章。 14 Stamen Design 基本都是数据可视化方面的文章。 15 FloatingSheep FloatingSheep是一个合作性质的研究组织，研究员来自于Kentucky大学和牛津大学，工作主要是Google Maps的数据挖掘方面。 16 Outside the Neatline 内容主要是关于地理信息系统的理论和实践。 17 Google Lat Long Blog 这个主要是由Google Maps的开发人员写的文章。 18 Geographika 关于GIS的纯技术文章，内容涉及OpenLayers、Spatial SQL和计算机硬件等。 19 Geospatial Analysts 如果你有GIS tools的问题，或你正在寻找解决GIS task的脚本，请到这里来。 20 GIS and Science Esri员工Matt Artz的博客，有大量曾发表在学术杂志上的文章。 21 EdParsons.com Google的地理空间技术大牛Ed Parsons的博客，内容非常广泛。 22 Odoe.net 大量GIS编程技术，含JavaScript、C#和Python。 23 Spatial Law and Policy 不是那种常规性科普博客，内容都是关于常见的GIS极专业的问题。 24 MapButcher 这个博客好久没更新了，但MapButcher这名字起的倒是很大气，地图屠夫。 25 Borderlines 都是发布在纽约时报上的文章，作者Frank Jacobs，都是有关地理学方面的。 26 Node Dangles 超好的GIS技术文章，内含大量示例代码。 27 MapBrief 地理空间分析文章。 28 GIS Studio 又一个带有示例代码的GIS博客。 29 GeoMusings 内容涉及开源技术、应用评论和GIS常见问题。 30 Volunteered Geographic Information 内容都是关于GIS的技术研究文章和空间分析讨论。 31 The Pragmatic Geographer 有关GIS 的应用评论和技术文摘。 32 A Cartographer’s Toolkit Gretchen Peterson的个人博客，主要是制图学方面。 33 Perrygeo 超好的地理空间方面的博客，内容涉及程序开发和开源软件。 34 Another GIS Blog 关于GIS方面的技术博客，涉及Python语言、ArcGIS和各种编程技巧。 35 Cafe Python N多代码示例，如果你是一个Esri用户并且擅长Python，那这里是天堂。 36 Fuzzy Tolerance 这个GIS博客不光名字好听，内容也不错哦。 37 Planet PostGIS 如果你正在寻找有关PostGIS的故事，到这里吧。 38 Gary’s Bloggage 各种地理相关性文章，包括Mapping和Web GIS。 39 Free and Open Source GIS Ramblings 作者Anita Graser，来自QGIS团队，同时也是OSGeo成员。 40 GIS Dude’s Weblog gisdude的博客，全都是地理相关文章。 41 Mappatondo 包含丰富的GIS相关代码示例（空间分析和mash-ups） 42 Spatial DBA Advisor 主要是空间数据库方面的文章，涉及Oracle和PostGIS。 43 Kelso’s Corner Nathaniel Vaughn Kelso的博客，GIS大牛。 44 Digitial Geography 在这里你会找到很多教程性的文章，内容包括GIS和统计学等，大部分都是由欧洲各院校的地理专业学生发布的。 45 AnyGeo Blog Glenn Letham的博客，这位大牛熟悉GIS领域各种应用，他的twitter是https://twitter.com/gletham。 46 blog.allanglen.com 内容包括地理空间信息技术和软件开发。 47 GIS Thought 既是博客又是论坛。 48 blog.davebouwman.com 作者Dave Bouwman，JavaScript开发人员，来自Esri DC团队，博客含大量代码示例和超有深度的技术文章。 49 Thunderhead Explorer 如果你从来没听过Mansour Raad的讲演，那就来这吧。好文超多，内部覆盖大数据和软件开发。 50 Smathermather’s Weblog 遥感、GIS、生态学和时髦技术。 51 Wherewithal 这个作者说，他每天脑袋里想的，不是地图就是啤酒。 52 BostonGIS Blog 基本都是PostGIS的新闻，也包括一些其他开源技术和geo-meetups。 53 Constant Geography Michael Busby，GIS领域的专家。 54 SDE Intercept 关于SDE的博客，想了解这方面的知识就来这吧。 55 GeoSprocket 作者Bill Morris，如果你想知道这个世界上发生了什么有关GIS的事，来这吧，要啥有啥。 56 Into the Pudding 关于地理空间技术的博客。","categories":[{"name":"GIS","slug":"GIS","permalink":"https://Screw1024.github.io/categories/GIS/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://Screw1024.github.io/tags/GIS/"},{"name":"blog","slug":"blog","permalink":"https://Screw1024.github.io/tags/blog/"}],"keywords":[{"name":"GIS","slug":"GIS","permalink":"https://Screw1024.github.io/categories/GIS/"}]},{"title":"为何建站","slug":"为何建站","date":"2019-03-05T03:23:07.000Z","updated":"2019-03-08T01:52:08.196Z","comments":true,"path":"thought/why this blog site-1551756187.html","link":"","permalink":"https://Screw1024.github.io/thought/why this blog site-1551756187.html","excerpt":"","text":"为何建站因为本人是地理信息科学专业的大三学生（2019年），作为交叉学科，我们在本科阶段要学的主要分为计算机编程知识、测绘遥感方面的专业知识、考研统考学科 基础学科知识。 搭建这个网站现阶段主要是为了记录在学习的过程中的技术收获，养成知识的归纳的习惯，另外就是写一些时事的看法 吐槽。😂 而最主要的目的，就是能够通过本站展示自己，如果能以此能找到三俩好友，幸甚至哉。😀 为何记录 人类区别于其他物种最重要的原因是，人类懂得记录，记录会推动人类反思，反思进而推动人类进步，而其他物种的生生不息大多只体现在繁衍上。 带着自己的思考记录，在自己回首再读的时候，或许能够发现当时的思维的局限，能够明白自己是否在进步。过年期间没事时，又看了一遍黎明之前跟大秦帝国，觉得自己能够对人物之间的解读突然上了一个层次，而这是突然发现的，所以想通过平时记录一些时事，一做学习之余的消遣，二为以后反思提供资料。 补充简言之，本站是一个记录技术和思考的原创个人博客。 现阶段主要是计算机方面的一些总结，可以获得成就奖嘛😜。以后打算走GIS开发路线，如果能够顺利，希望以后能够有机会写一些GIS方面的总结，因为本人能力有限，在学校阶段主要精力放在了计算机上了。 文章中如若发现错误或不当言论，还望您不吝赐教。 关于作者在校生，刚把前端基础学的差不多（顺带说下，通过搭建本站终于懂了node的模块化的好处了）。目前正在学Python，想学习一下Django以及爬虫，这些都是以后web gis的技术要求。 技术交流、开车交友请右转找微信小图标🙃","categories":[{"name":"思考","slug":"thought","permalink":"https://Screw1024.github.io/categories/thought/"}],"tags":[{"name":"thought","slug":"thought","permalink":"https://Screw1024.github.io/tags/thought/"},{"name":"hexo","slug":"hexo","permalink":"https://Screw1024.github.io/tags/hexo/"}],"keywords":[{"name":"思考","slug":"thought","permalink":"https://Screw1024.github.io/categories/thought/"}]},{"title":"喜欢听歌的人，内心可能有个戏精","slug":"我的爱好","date":"2019-03-05T03:23:07.000Z","updated":"2019-03-20T11:20:29.545Z","comments":true,"path":"thought/about my hobby-1551756187.html","link":"","permalink":"https://Screw1024.github.io/thought/about my hobby-1551756187.html","excerpt":"","text":"我的爱好作为一名音痴，不知为何对听音乐情有独钟。 哈哈，骗你的😜，我的想法是： 大概是歌曲里面的某句话突然叩击到我们内心的柔软，让我们在那一瞬间找到了共鸣，找到了一个倾诉的出口，很多时候我们会发现，把那些事情说出来以后，反倒释怀了，很多压在心里一直过不去的坎，在倾诉的那一刻，也得到了真正的释放和解脱。 如果你也喜欢听音乐，那太好了🙃。 喜欢的类型 民谣的调调很勾人，民谣的技巧是讲故事和打动听故事的人，民谣不普通，因为我们的生活可以很撩人。 Summer_夏叶子 最开始喜欢听的歌，现在想想有点吵吵😂，尤其喜欢bigbang，汪峰，当时觉得能给我带来的是力量吧，只要嗓门大，节奏强就是好歌，而现在喜欢的民谣宋东野的==安和桥==，这是心目中唯一一首TOP0级别的歌曲。 对把自己的经历写进歌的曲子，我都毫无抵抗力，而民谣是最佳媒介，个人觉得。 下面几首TOP1级别的： 朴树 的 那些花儿，平凡之路 Ed Sheeran 的 Photograph John Legend 的 All of Me 喜爱的歌手目前为止，只对两人佩服至极，其中一位便是歌手 朴树。 歌词特别诗化，嗓音又特别脆弱。他的歌“就像朗诵诗一样，脆弱就会特别打动人” 高晓松 《生如夏花》名字出自于泰戈尔的《飞鸟集》：“生如夏花之绚烂，死如秋叶之静美”。在绚烂至极之时，他选择了逃离，一夜之间，他消失了 原来以为他只是短暂的逃离，不曾想一走就是十年。 2014年朴树回来了，十年，多少风云变幻，多少沧海桑田，但他回来之时，还是有那么多人从拥挤的人潮中抽离出来，躲在某个角落里，眼角含着泪跟着朴树一起朗诵： 我曾经跨过山和大海，也穿过人山人海 我曾经拥有这一切，转眼都飘散如烟 我曾经失落失望失掉所有的方向 直到看见平凡 才是唯一的答案 《平凡之路》 任何情况下，朴树永远跟他的乐队同台演出，有电视台的跨年演唱会提出重金只请朴树一人（少出乐队费用），被他拒绝了，他答应过乐队“不会瞒着大家去接商演”。 他们跑去北京什刹海公园，在零下七八度的天气下唱着： 你是否得到了，期待的人生 梦里的海潮声，他们又如何 从指缝中划过，像在狂野里的风 《猎户星座》","categories":[{"name":"思考","slug":"thought","permalink":"https://Screw1024.github.io/categories/thought/"}],"tags":[{"name":"thought","slug":"thought","permalink":"https://Screw1024.github.io/tags/thought/"},{"name":"hobby","slug":"hobby","permalink":"https://Screw1024.github.io/tags/hobby/"}],"keywords":[{"name":"思考","slug":"thought","permalink":"https://Screw1024.github.io/categories/thought/"}]},{"title":"读曾国藩家书","slug":"读曾国藩家书","date":"2019-02-05T03:33:02.000Z","updated":"2019-03-08T07:01:59.314Z","comments":true,"path":"reading/《Zeng Guofan's Family Book》-1549337582.html","link":"","permalink":"https://Screw1024.github.io/reading/《Zeng Guofan's Family Book》-1549337582.html","excerpt":"","text":"曾文正公 谋国之忠，知人之明，自愧不如元辅；同心若金，攻错若石，相期无负平生。 [左宗棠] 师事近三十年，薪尽火传，筑室忝为门生长；威名震九万里，内安外攘，旷世难逢天下才。 [李鸿章] ​ 李鸿章对曾文正公的评价勉强算得上是彩虹屁了，毕竟给他打过工嘛😜。但是，何兆武教授的《上学记》里曾写过“中国历史上真正能够做到立德，立功，立言的只有二人：王阳明，曾国藩”，我想是比较公正的吧。 ​ 王阳明作为大哲学家，提出的“格物致知”，在中学语文中为难我半天，现在还有阴影😂，只能勉强从《曾国藩家书》入手啦。 拉家常​ 一封封看似聊着居家艰难的家书，字里行间蕴含的是对祖父母、父母、兄弟、妻儿、亲朋好友的浓浓的挂念、敬重、关怀、关心之情，每一封家书都洋溢着浓郁亲情。每次读到此书的写给父母的部分，羞愧之至，想到上了大一之后，解放了天性🙃，觉得父母的叮嘱就是唠叨，是一种约束，每个月打一次电话，到了大二才意识到不对，而且每次打电话更像是一种义务，只要完成了就好了，不是发自内心的尊重，现在想来，实在不应该。曾文正公即使身居高位，公务繁忙，还能如此，实在汗颜，今后要多跟家里汇报自己的状况。乌鸦的反哺之恩在于物质上，而在现代社会，人更注重的是精神的感受，所以我要做到好好生活，并让父母直到自己的成长，勉强能回馈父母。希望，以此文提醒自己。 ​ 记得有一封家书，写给亲戚资助，不要因为关系好而多给，关系不好而少给。一两句家长里短，道出“不患寡而患不均”的真谛了，凡此种种，须细细品读。 恒​ 在家书中，曾国藩教育自己的弟弟说：”凡人做一事，便须全副精神往此一事，首尾不懈。不可见异思迁，做这样想那样，坐这山望那山。“ ​ 曾文正公如此令人钦佩，其对于“恒”的执行，旷世独存 。古代儒家学者是何其多，能够写如此多的家书，上下五千年能有几人？读其家书，似乎挨着一个慈眉善目的老先生，捋捋花白的胡须，在你耳边娓娓而谈，那稀稀疏疏的胡须偶尔随风拂过你眼，说来的却是些家长里短，写给弟弟，儿女的都是通过一件件小事，来教其做人，照顾所有人的情绪。即便是对儿子的信中，也会说出自己那些地方做的不对，知道自己恒心不足，就严格控制自己，知道自己文章、诗词不好，就勤加练习。 ​ 坚持写家书只是曾文正公对于“恒”执行的一个方面，我想通过某一件事，基本就能大致知道其价值观，曾文正公的“恒”，是我最有感触的，也是首先要学习的。😁 谦​ 曾文正公给儿子的信中写道“自念贫窭无知，官至一品，寿逾五十，薄有浮名，兼秉兵权，忝窃万分，夫复何憾！”，作为清朝文臣之首，仍有一颗谦虚之心。当代大多数父母，给儿女们的教导都是命令式的，恰逢青春期孩子逆反心理，肯定容易发生矛盾，同时给孩子的命令，自己又不能做到，实在不能令孩子信服。我觉得，当父母要是能如曾文正公，谦虚，能承认自己的不足，对孩子的“期待”，自己能以身作则，方是良策。 ​ 不知道在哪看到的一句话“我们最大的错误， 是把最差的脾气和最糟糕的一面留给了最亲的人。 却把耐心和宽容给了陌生人。”，我觉得很有道理。对待孩子尚谦逊有礼，曾文正公对待别人也就不言而明了。 国藩素拘谨，其才不如胡左，而功倍之，独知人善用，是其特长 [陈公笃] ​ 谦虚，是知人善任的前提，如何能够发现别人的才能，承认别人的才能，在自己有能力是而任用之，谦虚是其第一步。😄","categories":[{"name":"读书","slug":"reading","permalink":"https://Screw1024.github.io/categories/reading/"}],"tags":[{"name":"book","slug":"book","permalink":"https://Screw1024.github.io/tags/book/"}],"keywords":[{"name":"读书","slug":"reading","permalink":"https://Screw1024.github.io/categories/reading/"}]},{"title":"Node创建服务器","slug":"Node创建服务器","date":"2018-11-08T14:18:56.000Z","updated":"2019-03-08T02:48:32.389Z","comments":true,"path":"frontend/Create server with Node-1541686736.html","link":"","permalink":"https://Screw1024.github.io/frontend/Create server with Node-1541686736.html","excerpt":"","text":"要点:​ 1.通过引入核心模块，来进行文件的读取和服务器的创建，并调用相应模块的API，进行想要的操作。 ​ 2.不同的文件类型进行不同的解析，主要通过Content-Type（多用途互联网邮件拓展）进行不同的定义，如html对应text/html，注意编码方式的声明，服务器默认是utf-8，但是浏览器编码方式是跟当前操作系统是一致的，win10中文操作系统是gbk编码方式，所以会造成乱码。 ​ 3.通过node启动服务器后，修改了被读取的文件，不需要重启服务器，因为他是动态读取文件的，通过之前建立的联系。 相关代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var http = require('http');var fs = require('fs');// 引入两个核心库var server = http.createServer();server.on('request',function(req,res)&#123; var url = req.url; // 获取输入的请求字符串url if(url === '/')&#123; //‘/’后是请求的路径 fs.readFile('./reource/halloword.html',function(err,data)&#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); res.end('老哥，没读出来，是不是路径或者文件名写错了啊'); &#125;else&#123; //data存取的是读取到的内容，是二进制的数据，通过toString转为字符串 //res.end()支持两种格式，二进制格式和字符串类型 res.setHeader('Content-Type','text/html; charset=utf-8'); // 注意和上面个text/plain的区别，通过text/html声明html类型文件 res.end(data); &#125; &#125;); &#125;else if(url === '/pushu')&#123; fs.readFile('./reource/pushu.jpeg',function(err,data)&#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); res.end('老哥，没读出来，是不是路径或者文件名写错了啊'); &#125;else&#123; //data存取的是读取到的内容，是二进制的数据，通过toString转为字符串 //res.end()支持两种格式，二进制格式和字符串类型 res.setHeader('Content-Type','image/jpeg'); // 图片反而不能声明utf-8编码格式他有特定的编码格式 res.end(data); &#125; &#125;); &#125;&#125;);server.listen(3000,function()&#123; console.log('老哥，安排好了');&#125;);​ 启动服务器： 效果：","categories":[{"name":"前端","slug":"frontend","permalink":"https://Screw1024.github.io/categories/frontend/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://Screw1024.github.io/tags/Node/"}],"keywords":[{"name":"前端","slug":"frontend","permalink":"https://Screw1024.github.io/categories/frontend/"}]},{"title":"大二完成的学生管理系统","slug":"大二写的学生管理系统","date":"2018-05-04T14:01:10.000Z","updated":"2019-03-08T02:02:11.262Z","comments":true,"path":"backend/Student management system-1525442470.html","link":"","permalink":"https://Screw1024.github.io/backend/Student management system-1525442470.html","excerpt":"","text":"一、创建关系 ​ 首先创建三个表student、teacherInfo、stndentInfo 分别用于存放学生基本信息、老师账户和密码、学生的学号和密码。 二、权限设置 ​ 分别建立老师和学生的登陆入口，通过入口信息判断后查询不同的表（关系），从而完成不同的操作人员的数据库的权限要求，老师可以看到全部信息，每个学生只能看到自己的信息。 ​ 为了区别不同的登陆人员，先定义两个RadioButton，由于学生人数比老师人数多的多，在学生的RadioButton的控件属性check中，选择为默认。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void btnOk_Click(object sender, EventArgs e) &#123; if (rbtnStudent.Checked) &#123; //选择的是学生对象 using (SqlConnection conn = new SqlConnection(\"Data Source=DESKTOP-BEUJ3C4;Initial Catalog=School2;User ID=sa;Password =2323010676;\")) &#123; conn.Open(); //打开数据库的连接 String sql = \"select * from stndentInfo where sno = @sno and spw = @spw\"; //创建数据库的操作字符串 SqlCommand cmd = new SqlCommand(sql, conn); //对指定的对象，操作字符串内容 cmd.Parameters.Add(new SqlParameter(\"@sno\", txtNo.Text)); //用参数代替占位符，线性更安全 cmd.Parameters.Add(new SqlParameter(\"@spw\", txtPw.Text)); SqlDataReader reader = cmd.ExecuteReader();//操作 if (reader.Read()) &#123; //如果查询到内容，跳转到Information界面，同时关闭当前界面 Information info = new Information(); info.Show(); this.Hide(); &#125; else &#123; MessageBox.Show(\"请输入正确信息！\"); &#125; &#125; &#125; else &#123; //这里只有两个选项，就没写条件，其余同上，注意对应的数据关系，表是不同的 using (SqlConnection conn = new SqlConnection(\"Data Source=DESKTOP-BEUJ3C4;Initial Catalog=School2;User ID=sa;Password =2323010676;\")) &#123; conn.Open(); String sql = \"select * from teacherInfo where userT = @userT and pwT = @pwT\"; SqlCommand cmd = new SqlCommand(sql, conn); cmd.Parameters.Add(new SqlParameter(\"@userT\", txtNo.Text)); cmd.Parameters.Add(new SqlParameter(\"@pwT\", txtPw.Text)); SqlDataReader reader = cmd.ExecuteReader(); if (reader.Read()) &#123; teacherUse teac = new teacherUse(); teac.Show(); this.Hide(); &#125; else &#123; MessageBox.Show(\"请输入正确信息！\"); &#125; &#125; &#125; &#125; //如果取消操作，关闭程序 private void btnCancel_Click(object sender, EventArgs e) &#123; this.Close(); &#125; 三、学生功能 ​ 完成修改密码，添加新的学生信息（为了方便），这里需要引起重视的是，这里的date类型需要进行转换，注意和老师界面查询是的date类型做出区分。 查询模块 12345678910111213141516171819202122232425262728293031private void btnOk_Click(object sender, EventArgs e) &#123; using (SqlConnection conn = new SqlConnection(\"Data Source=DESKTOP-BEUJ3C4;Initial Catalog=School2;User ID=sa;Password =2323010676;\")) &#123; conn.Open(); if (txtNewpw.Text == txtCheckpw.Text) &#123; string sql = String.Format(\"update stndentInfo set spw = @spw where sno = @sno\"); SqlCommand cmd = new SqlCommand(sql, conn); cmd.Parameters.Add(new SqlParameter(\"@sno\", txtUser.Text)); //这里注意也要写成txt.User.Text转换的是文本框里面的内容 cmd.Parameters.Add(new SqlParameter(\"@spw\", txtCheckpw.Text)); int rows = cmd.ExecuteNonQuery(); //这句话时执行的语句的必要的控制性的一句话 MessageBox.Show(\"新密码已经修改完成\"); &#125; else &#123; MessageBox.Show(\"请输入两次相同的密码\"); &#125; &#125; &#125; 修改密码模块 12345678910111213141516171819202122232425262728293031private void btnOk_Click(object sender, EventArgs e) &#123; using (SqlConnection conn = new SqlConnection(\"Data Source=DESKTOP-BEUJ3C4;Initial Catalog=School2;User ID=sa;Password =2323010676;\")) &#123; conn.Open(); if (txtNewpw.Text == txtCheckpw.Text) &#123; string sql = String.Format(\"update stndentInfo set spw = @spw where sno = @sno\"); SqlCommand cmd = new SqlCommand(sql, conn); cmd.Parameters.Add(new SqlParameter(\"@sno\", txtUser.Text)); //这里注意也要写成txt.User.Text转换的是文本框里面的内容 cmd.Parameters.Add(new SqlParameter(\"@spw\", txtCheckpw.Text)); int rows = cmd.ExecuteNonQuery(); //这句话时执行的语句的必要的控制性的一句话 MessageBox.Show(\"新密码已经修改完成\"); &#125; else &#123; MessageBox.Show(\"请输入两次相同的密码\"); &#125; &#125; &#125; 四、老师功能 ​ 查询学生的详细信息，注意date格式的转换，以及完成查询后的标签内容的转换。 对学生单个查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void btnOk_Click(object sender, EventArgs e) &#123; if(txtSno.Text == null) &#123; MessageBox.Show(\"请输入学号\"); &#125; else &#123; using (SqlConnection conn = new SqlConnection(\"Data Source=DESKTOP-BEUJ3C4;Initial Catalog=School2;User ID=sa;Password =2323010676;\")) &#123; conn.Open(); String sql = \"select * from student where sno = @sno\"; SqlCommand cmd = new SqlCommand(sql,conn); cmd.Parameters.Add(new SqlParameter(\"@sno\", txtSno.Text)); SqlDataReader reader = cmd.ExecuteReader(); if (reader.Read()) &#123; txtMajor.Text = reader.GetString(reader.GetOrdinal(\"smajor\")); txtSex.Text = reader.GetString(reader.GetOrdinal(\"sSex\")); txtName.Text = reader.GetString(reader.GetOrdinal(\"sname\")); DateTime dt = reader.GetDateTime(reader.GetOrdinal(\"sbirthday\")); //用Datetime格式接收时间对象 txtBirthday.Text = dt.ToShortDateString(); //将需要显示的内容转化成能在lable控件中显示的字符串 &#125; else &#123; //清除上一次查询标签中的内容，不然下次查询不显示查询出来的内容 txtSno.Text = null; txtSex.Text = null; txtName.Text = null; txtMajor.Text = null; txtBirthday.Text = null; MessageBox.Show(\"抱歉，没有查到对应学号的学生信息\"); &#125; &#125; &#125; &#125; 对学生进行分组查询 ​ 分组对学生进行查询，将结果添加进DataGirdView控件中，注意前面也提到了Anchor控制位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public partial class 学生信息查询 : Form &#123; public 学生信息查询() &#123; InitializeComponent(); &#125; private void 学生信息查询_Load(object sender, EventArgs e) &#123; //加载界面时，即添加下拉框里面的内容 cbxinfo.Items.Add(\"地信专业\"); cbxinfo.Items.Add(\"测绘专业\"); cbxinfo.Items.Add(\"物理专业\"); cbxinfo.Items.Add(\"外语专业\"); cbxinfo.Items.Add(\"中文专业\"); cbxinfo.Items.Add(\"计算机专业\"); &#125; private void btnOk_Click(object sender, EventArgs e) &#123; using (SqlConnection conn = new SqlConnection(\"Data Source=DESKTOP-BEUJ3C4;Initial Catalog=School;User ID=sa;Password =2323010676;\")) //这里使用的数据库是，前面查询信息作业添加的school数据库，用于存放学生的基本信息，及考试信息 &#123; conn.Open(); //String sql = \"select * from student where 所属专业 =@所属专业\"; String sql = String.Format( \"select * from student where 所属专业 ='&#123;0&#125;'\",cbxinfo.Text); SqlCommand cmd = new SqlCommand(); //创建数据库命令对象 // cmd.Parameters.Add(new SqlParameter(\"@所属专业\",cbxinfo.Text)); //将下拉框里面的文本代替参数信息 用参数不行，不知为什么，改用占位符 SqlDataAdapter sda = new SqlDataAdapter(sql, conn); //逐行查询，区别于SqlDataReader聚合查询 DataSet ds = new DataSet(); //创建容器，存放查询出来的对象 sda.Fill(ds);//将对象填充容器 dgvShow.DataSource = ds.Tables[0]; //绑定数据，将查询出来的第一个表数据显示在dgvShow中 &#125; &#125; &#125; 结果：","categories":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://Screw1024.github.io/tags/Database/"},{"name":"C#","slug":"C","permalink":"https://Screw1024.github.io/tags/C/"}],"keywords":[{"name":"后端","slug":"backend","permalink":"https://Screw1024.github.io/categories/backend/"}]}]}